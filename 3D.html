<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D City Scene with Three.js</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif;
        }
        canvas { 
            display: block; 
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
        button {
            margin: 5px;
            padding: 5px 10px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>3D City Scene</h2>
        <p>Use mouse to look around</p>
        <p>WASD keys to move</p>
        <p>Space/Shift to move up/down</p>
    </div>
    <div id="controls">
        <button id="dayNight">Toggle Day/Night</button>
        <button id="pauseTime">Pause Time</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0xa0a0a0, 0.001);

        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, 50);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 10;
        controls.maxDistance = 200;
        controls.maxPolarAngle = Math.PI / 2;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        scene.add(directionalLight);

        // Sun for day/night cycle
        const sun = new THREE.DirectionalLight(0xffffff, 1);
        sun.position.set(100, 100, 50);
        sun.castShadow = true;
        sun.shadow.mapSize.width = 2048;
        sun.shadow.mapSize.height = 2048;
        scene.add(sun);

        // Ground
        const groundGeometry = new THREE.PlaneGeometry(500, 500);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x333333,
            roughness: 0.8,
            metalness: 0.2
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // City grid
        const citySize = 200;
        const blockSize = 20;
        const roadWidth = 8;
        const sidewalkWidth = 2;
        const gridHelper = new THREE.GridHelper(citySize, citySize / blockSize, 0x555555, 0x555555);
        scene.add(gridHelper);

        // Buildings
        const buildings = [];
        const buildingColors = [0x8B4513, 0x4682B4, 0xA0522D, 0x708090, 0x556B2F];
        const buildingTypes = ['skyscraper', 'apartment', 'shop'];

        function createBuilding(type, x, z, width, depth, height, color) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.7,
                metalness: 0.1
            });
            
            // Add windows
            if (type === 'skyscraper' || type === 'apartment') {
                const windowColor = 0xADD8E6;
                const windowMaterial = new THREE.MeshStandardMaterial({ 
                    color: windowColor,
                    emissive: windowColor,
                    emissiveIntensity: Math.random() * 0.5,
                    roughness: 0.1,
                    metalness: 0.9
                });
                
                // Create window pattern
                const windowWidth = width * 0.8;
                const windowDepth = depth * 0.8;
                const windowGeometry = new THREE.BoxGeometry(windowWidth, height * 0.9, windowDepth);
                const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
                windowMesh.position.set(0, 0, 0);
                
                const buildingGroup = new THREE.Group();
                const buildingMesh = new THREE.Mesh(geometry, material);
                buildingGroup.add(buildingMesh);
                buildingGroup.add(windowMesh);
                buildingGroup.position.set(x, height / 2, z);
                buildingGroup.castShadow = true;
                buildingGroup.receiveShadow = true;
                
                return buildingGroup;
            } else {
                // Small shop
                const buildingMesh = new THREE.Mesh(geometry, material);
                buildingMesh.position.set(x, height / 2, z);
                buildingMesh.castShadow = true;
                buildingMesh.receiveShadow = true;
                
                // Add a sign
                const signGeometry = new THREE.BoxGeometry(width * 0.8, height * 0.1, depth * 0.1);
                const signMaterial = new THREE.MeshStandardMaterial({ color: 0xFF0000 });
                const sign = new THREE.Mesh(signGeometry, signMaterial);
                sign.position.set(x, height * 0.9, z + depth / 2);
                scene.add(sign);
                
                return buildingMesh;
            }
        }

        // Create city blocks
        for (let x = -citySize/2 + blockSize/2; x < citySize/2; x += blockSize) {
            for (let z = -citySize/2 + blockSize/2; z < citySize/2; z += blockSize) {
                // Skip some blocks for roads
                if (Math.abs(x) % (blockSize * 2) === 0 || Math.abs(z) % (blockSize * 2) === 0) {
                    continue;
                }
                
                const type = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                let width, depth, height;
                
                if (type === 'skyscraper') {
                    width = blockSize * 0.8;
                    depth = blockSize * 0.8;
                    height = 30 + Math.random() * 50;
                } else if (type === 'apartment') {
                    width = blockSize * 0.9;
                    depth = blockSize * 0.9;
                    height = 15 + Math.random() * 20;
                } else {
                    width = blockSize * 0.7;
                    depth = blockSize * 0.7;
                    height = 5 + Math.random() * 8;
                }
                
                const color = buildingColors[Math.floor(Math.random() * buildingColors.length)];
                const building = createBuilding(type, x, z, width, depth, height, color);
                scene.add(building);
                buildings.push(building);
            }
        }

        // Roads
        function createRoad(x, z, width, depth, rotation) {
            const geometry = new THREE.BoxGeometry(width, 0.2, depth);
            const material = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const road = new THREE.Mesh(geometry, material);
            road.position.set(x, 0.1, z);
            road.rotation.y = rotation;
            road.receiveShadow = true;
            
            // Add road markings
            if (rotation === 0) {
                const markingGeometry = new THREE.BoxGeometry(width * 0.8, 0.21, depth * 0.05);
                const markingMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
                
                for (let i = -depth/2 + 2; i < depth/2; i += 4) {
                    const marking = new THREE.Mesh(markingGeometry, markingMaterial);
                    marking.position.set(x, 0.11, z + i);
                    scene.add(marking);
                }
            } else {
                const markingGeometry = new THREE.BoxGeometry(width * 0.05, 0.21, depth * 0.8);
                const markingMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
                
                for (let i = -width/2 + 2; i < width/2; i += 4) {
                    const marking = new THREE.Mesh(markingGeometry, markingMaterial);
                    marking.position.set(x + i, 0.11, z);
                    scene.add(marking);
                }
            }
            
            return road;
        }

        // Create main roads
        for (let i = -citySize/2; i <= citySize/2; i += blockSize * 2) {
            // Horizontal roads
            const road1 = createRoad(0, i, citySize, roadWidth, 0);
            scene.add(road1);
            
            // Vertical roads
            const road2 = createRoad(i, 0, roadWidth, citySize, Math.PI/2);
            scene.add(road2);
            
            // Add sidewalks
            const sidewalkMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc });
            
            // Horizontal sidewalks
            const sidewalk1Geometry = new THREE.BoxGeometry(citySize, 0.3, sidewalkWidth);
            const sidewalk1a = new THREE.Mesh(sidewalk1Geometry, sidewalkMaterial);
            sidewalk1a.position.set(0, 0.15, i + roadWidth/2 + sidewalkWidth/2);
            scene.add(sidewalk1a);
            
            const sidewalk1b = new THREE.Mesh(sidewalk1Geometry, sidewalkMaterial);
            sidewalk1b.position.set(0, 0.15, i - roadWidth/2 - sidewalkWidth/2);
            scene.add(sidewalk1b);
            
            // Vertical sidewalks
            const sidewalk2Geometry = new THREE.BoxGeometry(sidewalkWidth, 0.3, citySize);
            const sidewalk2a = new THREE.Mesh(sidewalk2Geometry, sidewalkMaterial);
            sidewalk2a.position.set(i + roadWidth/2 + sidewalkWidth/2, 0.15, 0);
            scene.add(sidewalk2a);
            
            const sidewalk2b = new THREE.Mesh(sidewalk2Geometry, sidewalkMaterial);
            sidewalk2b.position.set(i - roadWidth/2 - sidewalkWidth/2, 0.15, 0);
            scene.add(sidewalk2b);
        }

        // Traffic lights
        function createTrafficLight(x, z, rotation) {
            const group = new THREE.Group();
            
            // Pole
            const poleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 5, 8);
            const poleMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.set(0, 2.5, 0);
            pole.castShadow = true;
            group.add(pole);
            
            // Box for lights
            const boxGeometry = new THREE.BoxGeometry(1, 2, 0.3);
            const boxMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const box = new THREE.Mesh(boxGeometry, boxMaterial);
            box.position.set(0, 5, 0);
            group.add(box);
            
            // Lights
            const redLightGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const yellowLightGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const greenLightGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            
            const redLightMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x888888,
                emissive: 0xff0000,
                emissiveIntensity: 0
            });
            const yellowLightMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x888888,
                emissive: 0xffff00,
                emissiveIntensity: 0
            });
            const greenLightMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x888888,
                emissive: 0x00ff00,
                emissiveIntensity: 0
            });
            
            const redLight = new THREE.Mesh(redLightGeometry, redLightMaterial);
            redLight.position.set(0, 5.5, 0.15);
            group.add(redLight);
            
            const yellowLight = new THREE.Mesh(yellowLightGeometry, yellowLightMaterial);
            yellowLight.position.set(0, 5, 0.15);
            group.add(yellowLight);
            
            const greenLight = new THREE.Mesh(greenLightGeometry, greenLightMaterial);
            greenLight.position.set(0, 4.5, 0.15);
            group.add(greenLight);
            
            group.position.set(x, 0, z);
            group.rotation.y = rotation;
            
            // Animation properties
            group.userData = {
                lights: { red: redLight, yellow: yellowLight, green: greenLight },
                state: 'red',
                timer: 0,
                cycleTime: 10 // seconds
            };
            
            return group;
        }

        // Add traffic lights at intersections
        const trafficLights = [];
        for (let i = -citySize/2 + blockSize; i < citySize/2; i += blockSize * 2) {
            for (let j = -citySize/2 + blockSize; j < citySize/2; j += blockSize * 2) {
                // Create 4 traffic lights at each intersection
                const tl1 = createTrafficLight(i - roadWidth/2 - 1, j, Math.PI/2);
                const tl2 = createTrafficLight(i + roadWidth/2 + 1, j, -Math.PI/2);
                const tl3 = createTrafficLight(i, j - roadWidth/2 - 1, 0);
                const tl4 = createTrafficLight(i, j + roadWidth/2 + 1, Math.PI);
                
                scene.add(tl1);
                scene.add(tl2);
                scene.add(tl3);
                scene.add(tl4);
                
                trafficLights.push(tl1, tl2, tl3, tl4);
            }
        }

        // Cars
        function createCar(x, z, color) {
            const group = new THREE.Group();
            
            // Car body
            const bodyGeometry = new THREE.BoxGeometry(3, 1, 5);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(0, 0.5, 0);
            body.castShadow = true;
            group.add(body);
            
            // Cabin
            const cabinGeometry = new THREE.BoxGeometry(2.5, 1, 3);
            const cabinMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
            cabin.position.set(0, 1.5, -0.5);
            group.add(cabin);
            
            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 16);
            wheelGeometry.rotateZ(Math.PI / 2);
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x111111 });
            
            const wheelPositions = [
                { x: 1.2, y: 0.5, z: 2 },
                { x: -1.2, y: 0.5, z: 2 },
                { x: 1.2, y: 0.5, z: -2 },
                { x: -1.2, y: 0.5, z: -2 }
            ];
            
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(pos.x, pos.y, pos.z);
                wheel.castShadow = true;
                group.add(wheel);
            });
            
            // Lights
            const frontLightGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const frontLightMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x888888,
                emissive: 0xffffaa,
                emissiveIntensity: 0
            });
            
            const frontLight1 = new THREE.Mesh(frontLightGeometry, frontLightMaterial);
            frontLight1.position.set(0.8, 0.7, 2.5);
            group.add(frontLight1);
            
            const frontLight2 = new THREE.Mesh(frontLightGeometry, frontLightMaterial);
            frontLight2.position.set(-0.8, 0.7, 2.5);
            group.add(frontLight2);
            
            const rearLightGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const rearLightMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x888888,
                emissive: 0xff0000,
                emissiveIntensity: 0
            });
            
            const rearLight1 = new THREE.Mesh(rearLightGeometry, rearLightMaterial);
            rearLight1.position.set(0.8, 0.7, -2.5);
            group.add(rearLight1);
            
            const rearLight2 = new THREE.Mesh(rearLightGeometry, rearLightMaterial);
            rearLight2.position.set(-0.8, 0.7, -2.5);
            group.add(rearLight2);
            
            group.position.set(x, 0.5, z);
            group.castShadow = true;
            
            // Animation properties
            group.userData = {
                speed: 0,
                maxSpeed: 0.5,
                acceleration: 0.01,
                braking: 0.02,
                turningSpeed: 0.02,
                targetLane: null,
                laneChangeProgress: 0,
                direction: new THREE.Vector3(0, 0, 1), // Initial forward direction
                frontLights: [frontLight1, frontLight2],
                rearLights: [rearLight1, rearLight2],
                lightState: 'off'
            };
            
            return group;
        }

        // Create cars
        const cars = [];
        const carColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
        
        for (let i = 0; i < 20; i++) {
            const lane = Math.floor(Math.random() * 4); // 0-3 for different lanes
            let x, z, rotation;
            
            if (lane === 0) {
                // Top lane (moving right)
                x = -citySize/2;
                z = -citySize/4 + Math.random() * (citySize/2);
                rotation = Math.PI/2;
            } else if (lane === 1) {
                // Right lane (moving down)
                x = -citySize/4 + Math.random() * (citySize/2);
                z = citySize/2;
                rotation = Math.PI;
            } else if (lane === 2) {
                // Bottom lane (moving left)
                x = citySize/2;
                z = -citySize/4 + Math.random() * (citySize/2);
                rotation = -Math.PI/2;
            } else {
                // Left lane (moving up)
                x = -citySize/4 + Math.random() * (citySize/2);
                z = -citySize/2;
                rotation = 0;
            }
            
            const color = carColors[Math.floor(Math.random() * carColors.length)];
            const car = createCar(x, z, color);
            car.rotation.y = rotation;
            scene.add(car);
            cars.push(car);
        }

        // Pedestrians
        function createPedestrian(x, z) {
            const group = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.BoxGeometry(0.5, 1, 0.5);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x3333ff });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(0, 0.5, 0);
            body.castShadow = true;
            group.add(body);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffdd99 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 1.3, 0);
            group.add(head);
            
            // Legs (for walking animation)
            const legGeometry = new THREE.BoxGeometry(0.2, 0.5, 0.2);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x0000aa });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, 0.25, 0);
            group.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, 0.25, 0);
            group.add(rightLeg);
            
            group.position.set(x, 0, z);
            group.castShadow = true;
            
            // Animation properties
            group.userData = {
                speed: 0.02,
                direction: new THREE.Vector3(Math.random() * 2 - 1, 0, Math.random() * 2 - 1).normalize(),
                legAngle: 0,
                legSpeed: 0.1,
                crossing: false,
                crossingProgress: 0
            };
            
            return group;
        }

        // Create pedestrians
        const pedestrians = [];
        for (let i = 0; i < 30; i++) {
            // Place pedestrians on sidewalks
            let x, z;
            if (Math.random() > 0.5) {
                // Horizontal sidewalk
                x = (Math.random() - 0.5) * citySize;
                z = Math.floor((Math.random() * (citySize / blockSize)) + 0.5) * blockSize - citySize/2;
                z += (Math.random() > 0.5 ? 1 : -1) * (roadWidth/2 + sidewalkWidth/2);
            } else {
                // Vertical sidewalk
                z = (Math.random() - 0.5) * citySize;
                x = Math.floor((Math.random() * (citySize / blockSize)) + 0.5) * blockSize - citySize/2;
                x += (Math.random() > 0.5 ? 1 : -1) * (roadWidth/2 + sidewalkWidth/2);
            }
            
            const pedestrian = createPedestrian(x, z);
            scene.add(pedestrian);
            pedestrians.push(pedestrian);
        }

        // Street furniture
        function createStreetLight(x, z) {
            const group = new THREE.Group();
            
            // Pole
            const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 6, 8);
            const poleMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.set(0, 3, 0);
            pole.castShadow = true;
            group.add(pole);
            
            // Light fixture
            const fixtureGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const fixtureMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                emissive: 0xffffaa,
                emissiveIntensity: 1
            });
            const fixture = new THREE.Mesh(fixtureGeometry, fixtureMaterial);
            fixture.position.set(0, 6, 0);
            group.add(fixture);
            
            // Light emission
            const light = new THREE.PointLight(0xffffaa, 1, 10, 2);
            light.position.set(0, 6, 0);
            group.add(light);
            
            group.position.set(x, 0, z);
            group.castShadow = true;
            
            return group;
        }

        function createBench(x, z, rotation) {
            const group = new THREE.Group();
            
            // Seat
            const seatGeometry = new THREE.BoxGeometry(2, 0.2, 0.5);
            const seatMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const seat = new THREE.Mesh(seatGeometry, seatMaterial);
            seat.position.set(0, 0.6, 0);
            seat.castShadow = true;
            group.add(seat);
            
            // Back
            const backGeometry = new THREE.BoxGeometry(2, 0.8, 0.1);
            const backMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const back = new THREE.Mesh(backGeometry, backMaterial);
            back.position.set(0, 1.1, -0.3);
            group.add(back);
            
            // Legs
            const legGeometry = new THREE.BoxGeometry(0.1, 0.6, 0.1);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            
            const leg1 = new THREE.Mesh(legGeometry, legMaterial);
            leg1.position.set(-0.9, 0.3, 0);
            group.add(leg1);
            
            const leg2 = new THREE.Mesh(legGeometry, legMaterial);
            leg2.position.set(0.9, 0.3, 0);
            group.add(leg2);
            
            group.position.set(x, 0, z);
            group.rotation.y = rotation;
            group.castShadow = true;
            
            return group;
        }

        function createTree(x, z) {
            const group = new THREE.Group();
            
            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(0, 1, 0);
            trunk.castShadow = true;
            group.add(trunk);
            
            // Leaves
            const leavesGeometry = new THREE.SphereGeometry(1.5, 16, 16);
            const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.set(0, 3, 0);
            leaves.castShadow = true;
            group.add(leaves);
            
            group.position.set(x, 0, z);
            group.castShadow = true;
            
            return group;
        }

        // Add street furniture
        for (let i = -citySize/2 + blockSize; i < citySize/2; i += blockSize) {
            for (let j = -citySize/2 + blockSize; j < citySize/2; j += blockSize) {
                // Skip intersections
                if (i % (blockSize * 2) === 0 || j % (blockSize * 2) === 0) continue;
                
                // Add street lights
                if (Math.random() < 0.3) {
                    let x, z;
                    if (Math.random() > 0.5) {
                        // Horizontal sidewalk
                        x = i;
                        z = j + (Math.random() > 0.5 ? 1 : -1) * (roadWidth/2 + sidewalkWidth/2);
                    } else {
                        // Vertical sidewalk
                        z = j;
                        x = i + (Math.random() > 0.5 ? 1 : -1) * (roadWidth/2 + sidewalkWidth/2);
                    }
                    
                    const light = createStreetLight(x, z);
                    scene.add(light);
                }
                
                // Add benches
                if (Math.random() < 0.2) {
                    let x, z, rotation;
                    if (Math.random() > 0.5) {
                        // Horizontal sidewalk
                        x = i;
                        z = j + (Math.random() > 0.5 ? 1 : -1) * (roadWidth/2 + sidewalkWidth/2 - 1);
                        rotation = Math.random() > 0.5 ? 0 : Math.PI;
                    } else {
                        // Vertical sidewalk
                        z = j;
                        x = i + (Math.random() > 0.5 ? 1 : -1) * (roadWidth/2 + sidewalkWidth/2 - 1);
                        rotation = Math.random() > 0.5 ? Math.PI/2 : -Math.PI/2;
                    }
                    
                    const bench = createBench(x, z, rotation);
                    scene.add(bench);
                }
                
                // Add trees
                if (Math.random() < 0.2) {
                    let x, z;
                    if (Math.random() > 0.5) {
                        // Horizontal sidewalk
                        x = i;
                        z = j + (Math.random() > 0.5 ? 1 : -1) * (roadWidth/2 + sidewalkWidth/2 + 1);
                    } else {
                        // Vertical sidewalk
                        z = j;
                        x = i + (Math.random() > 0.5 ? 1 : -1) * (roadWidth/2 + sidewalkWidth/2 + 1);
                    }
                    
                    const tree = createTree(x, z);
                    scene.add(tree);
                }
            }
        }

        // Crosswalks
        function createCrosswalk(x, z, rotation) {
            const group = new THREE.Group();
            
            const width = roadWidth - 2;
            const stripeWidth = width;
            const stripeDepth = 0.5;
            const gap = 0.5;
            
            const stripeGeometry = new THREE.BoxGeometry(stripeWidth, 0.1, stripeDepth);
            const stripeMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            
            const count = Math.floor(roadWidth / (stripeDepth + gap));
            const start = -((count - 1) * (stripeDepth + gap)) / 2;
            
            for (let i = 0; i < count; i++) {
                const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                stripe.position.set(0, 0.11, start + i * (stripeDepth + gap));
                group.add(stripe);
            }
            
            group.position.set(x, 0, z);
            group.rotation.y = rotation;
            
            return group;
        }

        // Add crosswalks at intersections
        for (let i = -citySize/2 + blockSize; i < citySize/2; i += blockSize * 2) {
            for (let j = -citySize/2 + blockSize; j < citySize/2; j += blockSize * 2) {
                // Horizontal crosswalks
                const cw1 = createCrosswalk(i, j - roadWidth/2, 0);
                const cw2 = createCrosswalk(i, j + roadWidth/2, 0);
                
                // Vertical crosswalks
                const cw3 = createCrosswalk(i - roadWidth/2, j, Math.PI/2);
                const cw4 = createCrosswalk(i + roadWidth/2, j, Math.PI/2);
                
                scene.add(cw1, cw2, cw3, cw4);
            }
        }

        // Time of day
        let time = 0;
        let timeSpeed = 0.005;
        let isDay = true;
        let timePaused = false;

        // UI controls
        document.getElementById('dayNight').addEventListener('click', () => {
            isDay = !isDay;
            if (isDay) {
                timeSpeed = Math.abs(timeSpeed);
            } else {
                timeSpeed = -Math.abs(timeSpeed);
            }
        });

        document.getElementById('pauseTime').addEventListener('click', () => {
            timePaused = !timePaused;
            this.textContent = timePaused ? 'Resume Time' : 'Pause Time';
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update controls
            controls.update();
            
            // Update time of day
            if (!timePaused) {
                time += timeSpeed;
                
                // Normalize time to 0-2π range
                if (time > Math.PI * 2) time -= Math.PI * 2;
                if (time < 0) time += Math.PI * 2;
                
                // Update sun position
                sun.position.x = Math.cos(time) * 100;
                sun.position.y = Math.sin(time) * 100;
                
                // Update sun intensity
                if (time > Math.PI) {
                    // Night time
                    sun.intensity = 0;
                    ambientLight.intensity = 0.1;
                    isDay = false;
                } else {
                    // Day time
                    sun.intensity = 1;
                    ambientLight.intensity = 0.4;
                    isDay = true;
                }
                
                // Update sky color
                const skyColor = new THREE.Color();
                if (time < Math.PI/6 || time > Math.PI*11/6) {
                    // Dawn/dusk
                    skyColor.setHSL(0.6, 0.7, 0.3);
                } else if (time >= Math.PI/6 && time <= Math.PI*5/6) {
                    // Day
                    const t = (time - Math.PI/6) / (Math.PI*2/3);
                    skyColor.setHSL(0.6 - t*0.2, 0.7 - t*0.3, 0.3 + t*0.5);
                } else if (time > Math.PI*5/6 && time < Math.PI*7/6) {
                    // Dusk
                    const t = (time - Math.PI*5/6) / (Math.PI/3);
                    skyColor.setHSL(0.4 + t*0.2, 0.4 + t*0.3, 0.8 - t*0.5);
                } else {
                    // Night
                    skyColor.setHSL(0.6, 0.7, 0.1);
                }
                
                scene.background = skyColor;
                scene.fog.color.copy(skyColor);
            }
            
            // Update traffic lights
            trafficLights.forEach(tl => {
                tl.userData.timer += 0.016; // Assuming 60fps
                
                if (tl.userData.timer >= tl.userData.cycleTime) {
                    tl.userData.timer = 0;
                    
                    // Cycle through states
                    if (tl.userData.state === 'red') {
                        tl.userData.state = 'red-yellow';
                    } else if (tl.userData.state === 'red-yellow') {
                        tl.userData.state = 'green';
                    } else if (tl.userData.state === 'green') {
                        tl.userData.state = 'yellow';
                    } else {
                        tl.userData.state = 'red';
                    }
                }
                
                // Update light materials
                tl.userData.lights.red.material.emissiveIntensity = 
                    (tl.userData.state === 'red' || tl.userData.state === 'red-yellow') ? 1 : 0;
                
                tl.userData.lights.yellow.material.emissiveIntensity = 
                    (tl.userData.state === 'yellow' || tl.userData.state === 'red-yellow') ? 1 : 0;
                
                tl.userData.lights.green.material.emissiveIntensity = 
                    tl.userData.state === 'green' ? 1 : 0;
            });
            
            // Update cars
            cars.forEach(car => {
                // Check for traffic lights ahead
                let shouldStop = false;
                const carDirection = new THREE.Vector3();
                car.getWorldDirection(carDirection);
                
                trafficLights.forEach(tl => {
                    const tlPosition = new THREE.Vector3();
                    tl.getWorldPosition(tlPosition);
                    
                    const toLight = new THREE.Vector3().subVectors(tlPosition, car.position);
                    const distance = toLight.length();
                    const angle = carDirection.angleTo(toLight);
                    
                    // Check if the light is in front of the car and close enough
                    if (distance < 20 && angle < Math.PI/4) {
                        // Check if the light is red or yellow
                        if (tl.userData.state === 'red' || tl.userData.state === 'yellow') {
                            shouldStop = true;
                        }
                    }
                });
                
                // Car behavior based on traffic lights
                if (shouldStop) {
                    // Slow down
                    if (car.userData.speed > 0) {
                        car.userData.speed = Math.max(0, car.userData.speed - car.userData.braking);
                    }
                    
                    // Turn on brake lights
                    car.userData.rearLights.forEach(light => {
                        light.material.emissiveIntensity = 1;
                    });
                    car.userData.lightState = 'braking';
                } else {
                    // Speed up
                    if (car.userData.speed < car.userData.maxSpeed) {
                        car.userData.speed = Math.min(car.userData.maxSpeed, car.userData.speed + car.userData.acceleration);
                    }
                    
                    // Turn on headlights at night
                    const headlightIntensity = isDay ? 0 : 1;
                    car.userData.frontLights.forEach(light => {
                        light.material.emissiveIntensity = headlightIntensity;
                    });
                    
                    // Turn off brake lights if they were on
                    if (car.userData.lightState === 'braking') {
                        car.userData.rearLights.forEach(light => {
                            light.material.emissiveIntensity = 0;
                        });
                        car.userData.lightState = isDay ? 'off' : 'headlights';
                    }
                }
                
                // Move car
                const moveDistance = car.userData.speed;
                car.translateZ(moveDistance);
                
                // Simple lane changing
                if (car.userData.targetLane === null && Math.random() < 0.005) {
                    car.userData.targetLane = (Math.random() - 0.5) * 2;
                }
                
                if (car.userData.targetLane !== null) {
                    car.userData.laneChangeProgress += 0.01;
                    const targetX = car.userData.targetLane;
                    const currentX = car.position.x;
                    
                    if (Math.abs(targetX - currentX) < 0.1 || car.userData.laneChangeProgress >= 1) {
                        car.userData.targetLane = null;
                        car.userData.laneChangeProgress = 0;
                    } else {
                        car.position.x = currentX + (targetX - currentX) * 0.05;
                    }
                }
                
                // Wrap around city bounds
                if (car.position.x > citySize/2) car.position.x = -citySize/2;
                if (car.position.x < -citySize/2) car.position.x = citySize/2;
                if (car.position.z > citySize/2) car.position.z = -citySize/2;
                if (car.position.z < -citySize/2) car.position.z = citySize/2;
            });
            
            // Update pedestrians
            pedestrians.forEach(ped => {
                // Check if pedestrian is at a crosswalk
                const isAtCrosswalk = Math.abs(ped.position.x % blockSize) < 1 || 
                                      Math.abs(ped.position.z % blockSize) < 1;
                
                if (isAtCrosswalk && !ped.userData.crossing && Math.random() < 0.01) {
                    // Start crossing the street
                    ped.userData.crossing = true;
                    ped.userData.crossingProgress = 0;
                    
                    // Determine crossing direction
                    if (Math.abs(ped.position.x % blockSize) < 1) {
                        // Cross horizontally
                        ped.userData.direction.set(Math.random() > 0.5 ? 1 : -1, 0, 0);
                    } else {
                        // Cross vertically
                        ped.userData.direction.set(0, 0, Math.random() > 0.5 ? 1 : -1);
                    }
                }
                
                if (ped.userData.crossing) {
                    // Continue crossing
                    ped.userData.crossingProgress += 0.01;
                    
                    // Move in crossing direction
                    ped.position.x += ped.userData.direction.x * ped.userData.speed;
                    ped.position.z += ped.userData.direction.z * ped.userData.speed;
                    
                    // Animate legs
                    ped.userData.legAngle += ped.userData.legSpeed;
                    ped.children[2].rotation.x = Math.sin(ped.userData.legAngle) * 0.5;
                    ped.children[3].rotation.x = Math.sin(ped.userData.legAngle + Math.PI) * 0.5;
                    
                    // Check if crossing is complete
                    if (ped.userData.crossingProgress >= 1) {
                        ped.userData.crossing = false;
                        
                        // Return to random walking
                        ped.userData.direction.set(
                            Math.random() * 2 - 1, 
                            0, 
                            Math.random() * 2 - 1
                        ).normalize();
                    }
                } else {
                    // Normal walking behavior
                    ped.position.x += ped.userData.direction.x * ped.userData.speed * 0.5;
                    ped.position.z += ped.userData.direction.z * ped.userData.speed * 0.5;
                    
                    // Animate legs
                    ped.userData.legAngle += ped.userData.legSpeed * 0.5;
                    ped.children[2].rotation.x = Math.sin(ped.userData.legAngle) * 0.3;
                    ped.children[3].rotation.x = Math.sin(ped.userData.legAngle + Math.PI) * 0.3;
                    
                    // Random direction change
                    if (Math.random() < 0.01) {
                        ped.userData.direction.set(
                            Math.random() * 2 - 1, 
                            0, 
                            Math.random() * 2 - 1
                        ).normalize();
                        
                        // Face walking direction
                        ped.rotation.y = Math.atan2(
                            ped.userData.direction.x, 
                            ped.userData.direction.z
                        );
                    }
                    
                    // Keep pedestrians on sidewalks
                    if (Math.abs(ped.position.x) > citySize/2 - 5 || 
                        Math.abs(ped.position.z) > citySize/2 - 5) {
                        // Turn around at city edges
                        ped.userData.direction.multiplyScalar(-1);
                        ped.rotation.y += Math.PI;
                    }
                }
            });
            
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start animation
        animate();
    </script>
</body>
</html>
